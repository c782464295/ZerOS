# ARM MMU
## 简介
MMU是Memory Management Unit的缩写，中文名是内存管理单元，它是中央处理器（CPU）中用来管理虚拟存储器、物理存储器的控制线路，同时也负责虚拟地址映射为物理地址，以及提供硬件机制的内存访问授权，多用户多进程操作系统。

物理地址：（英语：physical address），也叫实地址（real address）、二进制地址（binary address），它是在地址总线上，以电子形式存在的，使得数据总线可以访问主存的某个特定存储单元的内存地址。

虚拟地址：虚拟地址是相对于物理地址来说的。虚拟地址的提出，主要是为了解决在操作系统中，多线程内存地址重复，大进程在小内存运行等问题 ， 在32位系统中，虚拟地址空间中有4G，在操作系统中程序中使用的都是虚拟地址

mmu的作用有两点，地址翻译和内存保护。

在处理器上我们会运行一个操作系统，如linux,windows等，用户编写的源程序，需要经过编译，链接，生成可执行程序，人后被操作系统加载执行。在链接的时候同chan常我们要指定一个链接脚本，链接脚本的作用有很多，其中一个的作用是控制可执行文件的section的符号的内存布局，也就是控制ke'z可执行程序将来要在内存中哪里放置。操作系统会按照可执行程序的要求将其加载到内存的对应地址执行。假如用户A编写的应用程序的链接地址范围是0x100-0x200，用户B编写的应用程序的链接地址范围是0x100-0x200，这是很有可能的。因为给操作系统提供应用程序的开发者很多，不可能为每个开发者限定使用那些内存。这样，执行程序A的时候就不能执行程序B，执行程序B的时候就不能执行程序A，因为它们执行时会覆盖对方内存中的程序。为了解决这个问题，必须引入虚拟地址，为此操作系统和处理器都做了处理，添加了mmu，让其进行地址翻译。在程序载入内存的时候，操作系统会为其建立地址翻译表，处理器执行不同应用程序的时候，使用不同的地址翻译表。如下图所示。

地址翻译表的表项是一个虚拟地址对应一个物理地址，那么会占用太多的内存空间，为此，需要修改翻译方式，常用的有三种：页式、段式、段页式，这也是三种不同的内存管理方式。


### 页式 
页式内存管理将虚拟内存、物理内存空间划分为大小固定的块，每一块称之为一页，以页为单位来分配、管理、保护内存。此时MMU中的地址翻译表称为页表（Page Table），每个任务或进程对应一个页表，页表由若干个页表项（PTE：Page Table Entry）组成，每个页表项对应一个虚页，内含有关地址翻译的信息和一些控制信息。在页式内存管理方式中地址由页号和页内位移两部分组成，

### 段式
段式内存管理将虚拟内存、物理内存空间划分为段进行管理，段的大小取决于程序的逻辑结构，可长可短，一般将一个具有共同属性的程序代码和数据定义在一个段中。每个任务和进程对应一个段表（Section Table），段表由若干个段表项（STE：Section Table Entry）组成，内含地址映像信息（段基址和段长度）等内容。在段式虚拟存储器中，地址分为段号、段内位移两部分，使用段表进行地址翻译的过程与使用页表进行地址翻译的过程是相似的。

### 段页式
段页式内存管理是在内存分段的基础上再分页，即每段分成若干个固定大小的页。每个任务或进程对应有一个段表，每段对应有自己的页表。在访问存储器时，由CPU经页表对段内存储单元进行寻址。


### 内存保护 
内存保护也叫权限管理，除了具有地址翻译的功能外，还提供了内存保护功能。采用页式内存管理时可以提供页粒度级别的保护，允许对单一内存页设置某一类用户的读、写、执行权限，比如：一个页中存储代码，并且该代码不允许在用户模式下执行，那么可以设置该页的保护属性，这样当处理器在用户模式下要求执行该页的代码时，MMU会检测到并触发异常，从而实现对代码的保护。特别是在处理应用程序时，如果一个应用程序写的比较烂，出现了指针越界或栈溢出，程序跑飞等情况，因为不能访问别的程序的地址，所以不会影响到别的应用程序的运行。比如在操作系统下，应用程序不能访问寄存器，而操作系统可以。比如应用程序的只读数据段不能被写，否则会发生段错误。

### arm mmu
arm支持
supersection 16MB
sections 1MB
large pages 64KB
small pages 4KB
通常使用段式页表作为一级页表，使用页式式页表作为二级页表。


首先，我们要分清ARM CPU上的三个地址：虚拟地址(VA,Virtual Address)、变换后的虚拟地址(MVA,Modified Virtual Address)、物理地址(PA,Physical Address)

启动MMU后，CPU核对外发出虚拟地址VA，VA被转换为MVA供MMU使用，在这里MVA被转换为PA；最后通过PA读写实际设备 

 MMU的作用就是负责虚拟地址（virtual address）转化成物理地址（physical address）。 32位的CPU的虚拟地址空间达到4GB，在一级页表中使用4096个描述符来表示这4GB的空间，每个描述符代表1M的虚拟地址，要么存储了它的对应物理地址的起始地址，要么存储了下一级页表的地址。使用MVA[31:20]来索引一级页表（4096个描述符）（因为用MVA的高12位来索引，因此大小为 2^12 = 4096）


translation tabe base:简称ttb，称为转换表基址，存放在cp15的c2寄存器的高18位，低12位为0。所以将来我们写程序存放ttb的基地址一定要以16kb对齐。

modified virtual address:简称mva，称为转换后的虚拟地址（即在32bit系统中具有4G访问空间的虚拟地址），它的高12bit总共4096个项，用来作为该虚拟地址在ttb中的索引。它的低20位，是作为将来找到对应的物理内存的偏移。其本省也是在虚拟内存中的偏移。

address of first-level descriptor:一级地址描述符，它是结合ttb,以及偏移量mva，找到的具体的页表。即具体段（section）在那个位置。

first-level descriptor：以及页表描述符，上一步既然知道了是存放在一级页表的哪个位置了，直接取出其中的高12位，即找到了物理地址所在的段。

physcical address:既然上一步已经找到了物理地址所在的段，那么只需要加上低20位的段内偏移即找到了具体的那个物理地址了。（偏移在物理地址和虚拟地址中是一样的，区别只是在段地址）

## 实践
段页表为例，在裸机的情况下开启MMU，实现虚拟地址映射。

 在现代处理器中，为了使内存的速度跟得上CPU的速度，通常在芯片内部做了缓存（cache）。在启动了cache后，程序的运行效率会极大的提高。

arm中又把cache分为指令cache，又称（icache），和数据cache，又称（dcache）。

其中icache可以随时开启，随时关闭，但dcache必须在开启了MMU后，才能启动。

在启动cache后，arm其实才可以称为哈佛结构（数据指令分开）

否则，在不开启的情况下，其实还是冯洛伊曼结构。
