### HDMI文字显示
利用imgui中的资源，不用串口通讯。


Memory Mapped IO(MMIO)是与外围硬件交互的方式。通过读取或写入预定的内存地址来进行。
树莓派就是采用这种方式。

Peripheral就是一个有特定内存地址的硬件设备，可以在这个内存地址中写入或读出数据。

所有的外围设备有一个外围基地址(Peripheral Base Address)，在树莓派zero中基地址(GPIO_BASE)是0x20200000。

树莓派使用BCM2835，有的地方称为BCM2708。是arm-cotexA53架构

从技术上讲2708是该系列芯片的名称，而2835是Pi中的特定芯片。

除了 ARM 的内存管理单元（ MMU ）之外，BCM2835 还增加了一个粗颗粒的 MMU，用于将 ARM 的物理地址映射到系统总线地址。下面这幅图片展示了与之相关的地址空间。
![zero](images/Peripheral.png =1100x700)

左边的CPU总线是从0到FFFF,FFFF。8个f转换为10进制为4,294,967,295。说明CPU总线是4G
对arm的物理地址来说是1G
虚拟地址是4G

MMU
当程序超过1G物理地址就不够用了，这时候就有一个MMU单元，将物理地址映射为虚拟地址
我们写的所有代码操控的都是虚拟地址，从上层到底层使用的都是虚拟地址

这就是内核页表的映射——设计完页表之后通过MMU将物理地址映射到虚拟地址，页表决定了1M在虚拟地址的哪里被表示成4M（0-4或者10-14）

MMU没有，页表算法操作不了，就不能装Linux

在 ARM Linux 中的地址如下：

1. 首先是 ARM 内核规定的虚拟地址
2. 之后是 ARM MMU 映射的物理地址
3. 之后是 ARM mapping MMU 映射的总线地址
4. 最后为适当的外设和 RAM 地址


BCM2835 具有以下可以被 ARM 安全使用的外设：

芯片手册不需要每一条都细看，我们需要做哪一块的开发就去看哪一块
拷贝用到的DMA（快速拷贝单元），如果拷贝文件较大，CP指令就会很占CPU，cpu可以发动DMA来进行数据拷贝——直接内存访问单元

* 定时器
* 中断控制器
* GPIO
* USB
* PCM/I2S
* DMA
* I2C 主机
* I2C/SPI 从机
* SPI0,SPI1,SPI2
* PWM
* UART0,UART1

1.2.2 ARM 虚拟地址 （标准 Linux 内核）
一般情况下，BCM2835 标准的 Linux 内核在存储单元的头部对整个可使用的 RAM 进行了连续的地址映射。该内核被配置为在内核和用户使用的存储空间中分割了 1GB/3GB 的空间。

在 ARM 和 GPU 之间分割的区域用于存放一个支持的 start*.elf 文件，该文件被用作 SD 卡 FAT32 boot 区域的 start.elf。分配给 GPU 的最小存储量为 32MB，但是这将影响其多媒体性能；例如，32MB 的空间小于让 GPU 进行 1080p30 解码所需的缓存空间。

在内核模式下，虚拟地址为 0xC0000000 到 0xEFFFFFFF。

在用户模式下，即在运行 ARM Linux 时，虚拟内存为0x00000000 到 0xBFFFFFFF。

外设（物理地址为0x20000000）被映射到从地址 0xF20000000 处开始的内核虚拟地址空间。因此，在总线地址 0x7Ennnnnn 处的外设在 ARM 内核的虚拟地址为 0xF2nnnnnn。

1.2.3 ARM 物理地址
RAM 的物理地址从 0x00000000 处开始。

ARM 定义的 RAM 地址从 0x00000000 开始
只有在系统被配置为支持内存映射显示时，RAM 中的 VideoCore 部分才会被映射（这是常见情况）
VideoCore MMU 通过 VideoCore （和 VideoCore 外设）将 ARM 物理地址空间映射到总线地址空间。RAM 的总线地址被设置为映射到 VideoCore 内 uncache[^1] 总线地址 0xC0000000 处开始。

外设的物理地址是从 0x20000000 到0x20FFFFFF。外设的总线地址被映射到外设地址总线 0x7E000000 处开始。因此访问地址 0x7Ennnnnn 实际上是在访问物理地址 0x20nnnnnn。

1.2.4 总线地址
在本文中将外设地址称为总线地址。软件直接访问外设时，需要用如上所示的方式将地址转换位物理地址或虚拟地址。软件使用 DMA 访问外设时必须使用总线地址。

软件直接访问 RAM 时，必须使用物理地址（从0x00000000开始）。软件使用 DMA 访问 RAM 时，必须使用总线地址（从0xC0000000开始）。

1.3 外设访问内存的正确顺序
BCM2835 系统使用 AMBA AXI 兼容的接口结构。为了保证较低的系统复杂性和较高的数据吞吐量，BCM2835 的 AXI 系统并没有始终按照次序地返回数据[^2]。GPU 具有特殊的逻辑可以不按次序的拷贝数据，但是 ARM 内核并不支持这个逻辑。因此在使用 ARM 访问外设时必须予以警惕。

在访问同一个外设时，数据总是按照次序地返回。但当访问是从一个外设到另一个外设时，数据就可能会错乱。为了确保数据具有正确的顺序，最简单的方法是在代码的临界区域设置内存隔离指令（memory barrier instructions）。如下两点：

在首次写外设前设置一个内存写屏障
在最后一次读外设之后设置一个内存读屏障
并不是每一次读或写操作之后都需要设置一个内存隔离指令，仅在代码对一个外设读或写操作是跟在对另一不同外设执行读或写操作之后时才需要，这通常是在进入或者退出外设服务函数时。

在代码的任何位置都有可能产生中断，因此你需要有如下防护措施。如果在读一个外设时发生中断，则需要先设置一个内存读屏障，如果在写一个外设时发生中断，则需要在之后设置一个内存写屏障。

[1] BCM2835 上具有一个 128KB 的 L2 cache，主要用于 GPU。访问内存时是经过还是绕过 L2 cache 由总线地址的高两位决定。

[2] 一般来说，在执行两次读操作时，处理器假定数据是按序返回的。所以先从 X 位置处读数据再从 Y 位置处读取数据时，应先返回 X 位置的数据。返回数据的顺序发生错乱将导致错误的结果。例如：

a_status = *pointer_to_peripheral_a;
b_status = *pointer_to_peripheral_b;
没有采取预防措施时，a_status 和 b_status 的数值可能会发生交换。

理论上这可能会导致错误，但实际上这种情况很难发生，因为 AXI 系统可以确保数据始终被按序地送到目的地。因此：

*pointer_to_peripheral_a = value_a;
*pointer_to_peripheral_b = value_b;
一直是正确的。唯一可能出现错误的时候是不同的外设被连接到了相同的外部设备。


[树莓派pin](https://pinout.xyz/pinout/5v_power)